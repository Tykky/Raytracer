<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Raytracer: Project Implementation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Raytracer
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Project Implementation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md1"></a>
What is Raytracing?</h1>
<h2><a class="anchor" id="autotoc_md2"></a>
In the real world</h2>
<p>To oversimplify, light in real world travels from light source (sun, light bulb) to the observers eye. When light ray hits eye, different wavelengths are perceived as different colors. When light bounces from objects its wavelength is changed since some of its energy is absorbed. Energy of a photon depends on the wavelenth.</p>
<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a4a8c83479c76652ec6c8bc1a7cb6b4a7e89c3d0" alt="" class="inline"/></p>
<p>where h is <a href="https://en.wikipedia.org/wiki/Planck_constant">Plancks constant</a>, c is <a href="https://en.wikipedia.org/wiki/Speed_of_light">speed of light</a> and lambda being the wavelength.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
In raytracing</h2>
<p>In raytracing the light rays are sent from the eye to the light source. In the algorithm the <em>camera</em> represents the eye. The light rays traverse the world backwards (eye -&gt; light source) and not like in the real world (light source -&gt; eye). The "real world" model is computationally not optimal since most of the light rays wouldn't even hit the camera.</p>
<p>Wikipedia page about raytracing demonstrates the general idea. Note that the (Blinn-Phong) model is not implemented in this project. Area lights are not implemented either. When ray hits "void" (0 solutions), it's considered that it hits "sky" and color is computed accordinly.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/9/95/Ray_Tracing_Illustration_First_Bounce.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="autotoc_md4"></a>
Overview</h1>
<p>Technically the implemented algorithm corresponds more closely to <a href="https://en.wikipedia.org/wiki/Path_tracing">path tracer</a> than <a href="https://en.wikipedia.org/wiki/Ray_tracing_(graphics)">ray tracers</a>. The main difference is that path tracing uses random sampling and ray tracing does not. Path tracer will produce noise when used with low sample count. The more samples are used the more accurate (less noisy) the final output will be. This type of approach is often referred as the <a href="https://en.wikipedia.org/wiki/Monte_Carlo_method">Monte Carlo method</a>.</p>
<p>The project is done without any external dependencies (excluding googletests and openMP).</p>
<h1><a class="anchor" id="autotoc_md5"></a>
Classes</h1>
<h2><a class="anchor" id="autotoc_md6"></a>
Vector3D</h2>
<p><a class="el" href="classVector3D.html" title="Vector3D class containing data structure for 3D-euclidean and RGB vectors.">Vector3D</a> class contains data structure for 3 dimensional euclidean and RGB vectors. This includes arithmetic operations between <a class="el" href="classVector3D.html" title="Vector3D class containing data structure for 3D-euclidean and RGB vectors.">Vector3D</a> objects. The whole vector class is inlined to improve performance. Majority of the operations done by the algorithm are done using vectors. Hence these are called millions of times in a short timespan. Therefore operation call overhead causes significant impact.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Ray</h2>
<p>The ray class handles mapping between two <a class="el" href="classVector3D.html" title="Vector3D class containing data structure for 3D-euclidean and RGB vectors.">Vector3D</a> vectors. These two vectors are named origin and direction. While regular euclidean vectors have length and direction. The ray has position, length and direction. The ray class has member function to return arbitrary point along it's span. This feature is used to solve the hit equation or ray intersection equation.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
Camera</h2>
<p>The camera consist of eye and screen. Rays are traversed from eye to screen and then out to the world. The screen corresponds to the rendered image. Each pixel on the screen is mapped to a ray which intersects the eye and the pixel it's called from.</p>
<p><object type="image/svg+xml" data="./data/sketches/camera.svg" style="pointer-events: none;"></object> The sketch shows how the trigonometric formulas used in the implementation are derived.</p>
<h2><a class="anchor" id="autotoc_md9"></a>
Engine</h2>
<p>The engine class is used to do the actual rendering process. The <em>screen</em> (in camera sketch) is traversed with nested for loops. The parallelization is done by splitting the nested for loop into segments (rectangles on screen) and assigning each segment to a separate thread. Each thread processes then pixels on it's own segment in parallel. Implementing the paralellization this way causes no critical sections in the code. Library called openMP is used to do the parallelization.</p>
<p>Each pixel inside each segment is mapped to a ray and then the ray is send out to the world to see how it bounces from different objects. Color for each pixel is computed based on these bounces. This mapping is done multiple times using slight variation in (x,y) screen coordinate and then the color from these <em>samples</em> is averaged. This is called random <a href="https://en.wikipedia.org/wiki/Supersampling">supersampling</a>. The idea is to remove jagged edges from the final image.</p>
<p>Now these samples are also used to produce scatter rays. Rays can be set to bounce in random directions or set to bounce by probability distribution. Meaning rays will bounce differently on each sample. This is helpful when trying to simulate <a href="https://en.wikipedia.org/wiki/Global_illumination">global illumination</a>. When probability distribution is used to distribute light the term <a href="https://en.wikipedia.org/wiki/Path_tracing">Monte Carlo Path tracing</a> or just path tracing is used instead of raytracing.</p>
<p>Downside of this method is that the final image is usually noisy. Increasing sample count can be used to combat this issue but with diminishing returns. Another popular method to combat this is to use denoise algorithm which isn't implemented in this project.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
Primitives</h2>
<h3><a class="anchor" id="autotoc_md11"></a>
Abstract primitive</h3>
<p>Abstract primitive class or just <a class="el" href="classPrimitive.html" title="Primitive is abstract class which provides interface for all primitives in the world....">Primitive</a> class provides interface for all "primitives". Primitives are objects in the world which cannot be divided into smaller pieces e.g triangles, polygons or spheres. All of the classes which inherit this class must have "hit" member function. Hit member function solves the hit equation or ray intersection equation. The hit equation for is different for each primitive.</p>
<h3><a class="anchor" id="autotoc_md12"></a>
Primitivelist</h3>
<p><a class="el" href="classPrimitivelist.html" title="Primitivelist is a data structure for keeping track of all primitives in the world.">Primitivelist</a> is data structure for keeping track of all objects in the world. This inherits the abstract primitive class, meaning <a class="el" href="classPrimitivelist.html" title="Primitivelist is a data structure for keeping track of all primitives in the world.">Primitivelist</a> has hit() member function. When this member function is called, all of the objects in this list are tested against ray r (given as parameted in hit()) and the closest hit to the camera is returned. This enables multiple objects in the world.</p>
<h3><a class="anchor" id="autotoc_md13"></a>
Sphere</h3>
<p><a class="el" href="classSphere.html" title="sphere primitive handles handles the mathematical representation of a sphere.">Sphere</a> class defines the sphere primitive. This inherits the abstract primitive class. The hit equation for the sphere is formulated using vectors</p>
<h2><a class="anchor" id="autotoc_md14"></a>
Materials</h2>
<p>All preview images of materials are rendered at 400x400 and 1000 samples is used per pixel. The mentioned render times are with Amd Ryzen 9 3900x processor (12 cores).</p>
<h3><a class="anchor" id="autotoc_md15"></a>
Abstract material</h3>
<p>Abstract material class works similarly to abstract primitive class. This defines interface for all materials in the world. All materials have scatter() member function which determines direction for a ray when it bounces from surface with this material. Note that some materials can let ray to pass through surface. Materials and primitives are closely linked since computing a scatter/bounce ray requires information about the surface it hits and the material.</p>
<h3><a class="anchor" id="autotoc_md16"></a>
Lambertian</h3>
<p><a class="el" href="classLambertian.html" title="Lambertian material is &quot;matte&quot; or diffusely reflecting Material.">Lambertian</a> material is diffusively reflecting or "matte" material. Rays are reflected to random directions. The real mathematical representation of <em><a class="el" href="classLambertian.html" title="Lambertian material is &quot;matte&quot; or diffusely reflecting Material.">Lambertian</a></em> does not scatter rays by random hence this implementation is only a approximation.</p>
<p><img src="data/materials/lambertian.png" alt="" class="inline"/></p>
<h3><a class="anchor" id="autotoc_md17"></a>
Metal</h3>
<p><a class="el" href="classMetal.html" title="Metal is highly reflective Material which mirrors all rays.">Metal</a> material is highly reflective material. Rays are mirrored using surface normal as axis of symmetry. Blur can be added to reflections by adding slight random variation to the reflecting ray.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">blur 0, render time 2.7 s </th><th class="markdownTableHeadCenter">blur 0.3, render time 3.0 s </th><th class="markdownTableHeadCenter">blur 0.9, render time 3.0 s  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><img src="data/materials/metal1.png" alt="" class="inline"/> </td><td class="markdownTableBodyCenter"><img src="data/materials/metal2.png" alt="" class="inline"/> </td><td class="markdownTableBodyCenter"><img src="data/materials/metal3.png" alt="" class="inline"/>  </td></tr>
</table>
<p>Render time slightly increases when blur != 0 since random generator is used to produce the blurriness.</p>
<h3><a class="anchor" id="autotoc_md18"></a>
Dielectric</h3>
<p><a class="el" href="classDielectric.html" title="Dielectric material allows rays to pass through objects. It can simulate materials like water or glas...">Dielectric</a> material allows rays to pass through surfaces. <a href="https://en.wikipedia.org/wiki/Snell%27s_law">Snell's law</a> is used to compute the refraction angle. Usually Snell's law is represented in form:</p>
<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b5a73124df21668801a4d20054bb1b13f6709752" alt="eq1" class="inline"/></p>
<p>Since rays are computed using vectors, the vector form is used instead:</p>
<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/3aaad4c15e93ec17fe2a8a90e2269fc260e947e9" alt="eq2" class="inline"/></p>
<p>r is index of refraction (ior), c is dot product of normal and ray vector l. The Snell's law is combined with Fresnel effect which is usually described with <a href="https://en.wikipedia.org/wiki/Fresnel_equations">Fresnel equations</a>. Instead of these equations a <a href="https://en.wikipedia.org/wiki/Schlick%27s_approximation">approximation</a> by Christophe Schlick is used. This is by far the most complicated material the renderer supports. The dielectric material has one parameter which is ior (<a href="https://en.wikipedia.org/wiki/Refractive_index">index of refraction</a>).</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">ior 1.0 (vacuum), render time 3.5 s </th><th class="markdownTableHeadCenter">ior 1.33 (water), render time 3.7 s </th><th class="markdownTableHeadCenter">ior 2.65 (<a href="https://en.wikipedia.org/wiki/Moissanite">moissanite</a>), render time 13.3 s  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><img src="data/materials/dielectric1.png" alt="" class="inline"/> </td><td class="markdownTableBodyCenter"><img src="data/materials/dielectric2.png" alt="" class="inline"/> </td><td class="markdownTableBodyCenter"><img src="data/materials/dielectric3.png" alt="" class="inline"/>  </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md19"></a>
Brdf (Bidirectional reflectance distribution function)</h2>
<p>The brdf defines how rays are reflected in general. This blends the use of lambertian, metal materials and the Fresnel effect in one material. Probability is used to determine how the ray should be reflected.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">metalness 0, render time 4.8 s </th><th class="markdownTableHeadCenter">metalness 0.1, render time 4.6 s </th><th class="markdownTableHeadCenter">metalness 0.5, render time 4.2 s  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><img src="data/materials/brdf1.png" alt="" class="inline"/> </td><td class="markdownTableBodyCenter"><img src="data/materials/brdf2.png" alt="" class="inline"/> </td><td class="markdownTableBodyCenter"><img src="data/materials/brdf3.png" alt="" class="inline"/>  </td></tr>
</table>
<p>Reflections can have different color and roughness (metal blurriness). With values roughness = 0.2 and</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">metalness 0.1, render time 4.8 s </th><th class="markdownTableHeadCenter">metalness 0.5, render time 4.2 s </th><th class="markdownTableHeadCenter">metalness 0.8, render time 4.2 s  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><img src="data/materials/brdf4.png" alt="" class="inline"/> </td><td class="markdownTableBodyCenter"><img src="data/materials/brdf5.png" alt="" class="inline"/> </td><td class="markdownTableBodyCenter"><img src="data/materials/brdf6.png" alt="" class="inline"/>  </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md20"></a>
Functions</h1>
<h2><a class="anchor" id="autotoc_md21"></a>
Recursive scatter</h2>
<p>The function <a class="el" href="Engine_8h.html#a20c90081299629be93cb2f5f87da2fc4" title="Scatters rays recursively based on material it hits.">recursiveScatter()</a> handles the recursive calling of the scatter() member function which is defined by all material classes. The recursiveScatter function is:</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">Vector3D recursiveScatter(const Ray &amp;r, Primitive *world, int depth, function&lt;float()&gt; &amp;randomFloat,</div>
<div class="line">                          const int depthlimit) {</div>
<div class="line">    hitrecord record;</div>
<div class="line"> </div>
<div class="line">    const float floaterror = 0.001;</div>
<div class="line"> </div>
<div class="line">    if (world-&gt;hit(r, floaterror, numeric_limits&lt;float&gt;::max(), record)) {</div>
<div class="line"> </div>
<div class="line">        Ray scatter;</div>
<div class="line">        Vector3D attenuation;</div>
<div class="line"> </div>
<div class="line">        if (depth &lt; depthlimit &amp;&amp; record.matptr-&gt;scatter(r, record, attenuation, scatter, randomFloat)) {</div>
<div class="line">            return attenuation * recursiveScatter(scatter, world, depth + 1, randomFloat, depthlimit);</div>
<div class="line">        } else {</div>
<div class="line">            return Vector3D();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    return skyGradient(r);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The function is called first time with ray given by the camera. After that it calls recursively itself on every bounce. The <em>attenuation</em> is used to alter the color after each bounce. This is done with simple multiplication as shown in the code. This idea is similiar to photon losing some of its energy after it bounces from objects (as described in the very beginning of this document).</p>
<h1><a class="anchor" id="autotoc_md22"></a>
Sources</h1>
<p><a href="https://en.wikipedia.org/wiki/Ray_tracing_(graphics)">Ray tracing (graphics), wikipedia</a></p>
<p><a href="https://en.wikipedia.org/wiki/Path_tracing">Path Tracing, wikipedia</a></p>
<p><a href="https://en.wikipedia.org/wiki/Bounding_volume_hierarchy">Bounding volume hierarchy, wikipedia</a></p>
<p><a href="https://en.wikipedia.org/wiki/Monte_Carlo_method">Monte Carlo method</a></p>
<p><a href="https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm">MÃ¶ller-trumbore intersection algorithm, wikipedia</a></p>
<p><a href="https://www.graphics.cornell.edu/~bjw/mca.pdf">Cost Analysis of a Ray Tracing algorithm, Bruce Walter and Peter Shirley, July 23, 1997</a></p>
<p><a href="https://raytracing.github.io/">Ray Tracing In One Weekend - The Book Series, Peter Shirley</a></p>
<p><a href="https://en.wikipedia.org/wiki/Snell%27s_law">Snell's law, wikipedia</a></p>
<p><a href="https://en.wikipedia.org/wiki/Schlick%27s_approximation">Schlick's approximation, wikipedia</a></p>
<p><a href="https://en.wikipedia.org/wiki/Moissanite">Moissanite, wikipedia</a></p>
<p><a href="https://en.wikipedia.org/wiki/Refractive_index">Refractive index, wikipedia</a> <a href="https://en.wikipedia.org/wiki/Photon_energy">Photon energy, wikipedia</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
